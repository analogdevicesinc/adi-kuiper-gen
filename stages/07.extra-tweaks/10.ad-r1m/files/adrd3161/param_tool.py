import argparse
import canopen
import time
from pathlib import Path
import argparse
import re

def int_flexible(x):
    return int(x, 0)

parser = argparse.ArgumentParser(description="ADRD3161 tuning parameter helper")

parser.add_argument("-i", "--iface", type=str, help="CAN interface", default="can0")
parser.add_argument("-e", "--eds", type=str, help="EDS file", default="adrd3161.eds")
parser.add_argument("node", type=int_flexible, help="Target node ID", default=0x17)

sp = parser.add_subparsers(dest='subcommand', required=True)

read = sp.add_parser('read', help='Read current TMC9660 RWE parameters, optionally converting them to other formats')
read.add_argument('format', choices=('ini', 'python', 'lely'), default='ini')

write = sp.add_parser('write', help='Write and persist TMC9660 RWE parameters')
write.add_argument('file', type=str, help="INI file with new parameter values. Missing parameters will keep their previous values.")

reset = sp.add_parser('reset', help='Delete all stored RWE parameters, restoring defaults')

args = parser.parse_args()

net = canopen.Network()
net.connect(channel=args.iface, interface='socketcan')

node = net.add_node(args.node, args.eds)

node.nmt.wait_for_heartbeat()

rwe_params = [ "MOTOR_TYPE", "MOTOR_POLE_PAIRS", "MOTOR_DIRECTION", "MOTOR_PWM_FREQUENCY", "OUTPUT_VOLTAGE_LIMIT", "MAX_TORQUE", "MAX_FLUX", "PWM_SWITCHING_SCHEME", "IDLE_MOTOR_PWM_BEHAVIOR", "ADC_SHUNT_TYPE", "CSA_GAIN_ADC_I0_TO_ADC_I2", "CSA_GAIN_ADC_I3", "CSA_FILTER_ADC_I0_TO_ADC_I2", "CSA_FILTER_ADC_I3", "CURRENT_SCALING_FACTOR", "PHASE_UX1_ADC_MAPPING", "PHASE_VX2_ADC_MAPPING", "PHASE_WY1_ADC_MAPPING", "PHASE_Y2_ADC_MAPPING", "ADC_I0_SCALE", "ADC_I1_SCALE", "ADC_I2_SCALE", "ADC_I3_SCALE", "ADC_I0_INVERTED", "ADC_I1_INVERTED", "ADC_I2_INVERTED", "ADC_I3_INVERTED", "ADC_I0_OFFSET", "ADC_I1_OFFSET", "ADC_I2_OFFSET", "ADC_I3_OFFSET", "OPENLOOP_CURRENT", "OPENLOOP_VOLTAGE", "ACCELERATION_FF_GAIN", "ACCELERATION_FF_SHIFT", "RAMP_ENABLE", "DIRECT_VELOCITY_MODE", "RAMP_AMAX", "RAMP_A1", "RAMP_A2", "RAMP_DMAX", "RAMP_D1", "RAMP_D2", "RAMP_VMAX", "RAMP_V1", "RAMP_V2", "RAMP_VSTART", "RAMP_VSTOP", "RAMP_TVMAX", "RAMP_TZEROWAIT", "ACCELERATION_FEEDFORWARD_ENABLE", "VELOCITY_FEEDFORWARD_ENABLE", "HALL_SECTOR_OFFSET", "HALL_FILTER_LENGTH", "HALL_POSITION_0_OFFSET", "HALL_POSITION_60_OFFSET", "HALL_POSITION_120_OFFSET", "HALL_POSITION_180_OFFSET", "HALL_POSITION_240_OFFSET", "HALL_POSITION_300_OFFSET", "HALL_INVERT_DIRECTION", "HALL_EXTRAPOLATION_ENABLE", "HALL_PHI_E_OFFSET", "ABN_1_STEPS", "ABN_1_DIRECTION", "ABN_1_INIT_METHOD", "ABN_1_INIT_DELAY", "ABN_1_INIT_VELOCITY", "ABN_1_N_CHANNEL_PHI_E_OFFSET", "ABN_1_N_CHANNEL_INVERTED", "ABN_1_N_CHANNEL_FILTERING", "TORQUE_P", "TORQUE_I", "FLUX_P", "FLUX_I", "SEPARATE_TORQUE_FLUX_PI_PARAMTERS", "CURRENT_NORM_P", "CURRENT_NORM_I", "VELOCITY_SENSOR_SELECTION", "VELOCITY_P", "VELOCITY_I", "VELOCITY_NORM_P", "VELOCITY_NORM_I", "VELOCITY_SCALING_FACTOR", "VELOCITY_LOOP_DOWNSAMPLING", "VELOCITY_REACHED_THRESHOLD", "VELOCITY_METER_SWITCH_THRESHOLD", "VELOCITY_METER_SWITCH_HYSTERESIS", "POSITION_SENSOR_SELECTION", "POSITION_SCALING_FACTOR", "POSITION_P", "POSITION_I", "POSITION_NORM_P", "POSITION_NORM_I", "STOP_ON_POSITION_DEVIATION", "POSITION_LOOP_DOWNSAMPLING", "POSITION_LIMIT_LOW", "POSITION_LIMIT_HIGH", "POSITION_REACHED_THRESHOLD", "REFERENCE_SWITCH_ENABLE", "REFERENCE_SWITCH_POLARITY_AND_SWAP", "REFERENCE_SWITCH_LATCH_SETTINGS", "EVENT_STOP_SETTINGS", "REFERENCE_SWITCH_SEARCH_MODE", "REFERENCE_SWITCH_SEARCH_SPEED", "REFERENCE_SWITCH_SPEED", "ABN_2_STEPS", "ABN_2_DIRECTION", "ABN_2_GEAR_RATIO", "ABN_2_ENABLE", "SPI_ENCODE_CS_SETTLE_DELAY_TIME", "SPI_ENCODER_CS_IDLE_DELAY_TIME", "SPI_ENCODER_MAIN_TRANSFER_CMD_SIZE", "SPI_ENCODER_SECONDARY_TRANSFER_CMD_SIZE", "SPI_ENCODER_TRANSFER_DATA_3_0", "SPI_ENCODER_TRANSFER_DATA_7_4", "SPI_ENCODER_TRANSFER_DATA_11_8", "SPI_ENCODER_TRANSFER_DATA_15_12", "SPI_ENCODER_TRANSFER", "SPI_ENCODER_POSITION_COUNTER_MASK", "SPI_ENCODER_POSITION_COUNTER_SHIFT", "SPI_ENCODER_INITIALIZATION_METHOD", "SPI_ENCODER_DIRECTION", "SPI_ENCODER_OFFSET", "SPI_LUT_CORRECTION_ENABLE", "STEP_DIR_STEP_DIVIDER_SHIFT", "BRAKE_CHOPPER_ENABLE", "BRAKE_CHOPPER_VOLTAGE_LIMIT", "BRAKE_CHOPPER_HYSTERESIS", "RELEASE_BRAKE", "BRAKE_RELEASING_DUTY_CYCLE", "BRAKE_HOLDING_DUTY_CYCLE", "BRAKE_RELEASING_DURATION", "INVERT_BRAKE_OUTPUT", "THERMAL_WINDING_TIME_CONSTANT_1", "IIT_LIMIT_1", "THERMAL_WINDING_TIME_CONSTANT_2", "IIT_LIMIT_2", "PWM_L_OUTPUT_POLARITY", "PWM_H_OUTPUT_POLARITY", "BREAK_BEFORE_MAKE_TIME_LOW_UVW", "BREAK_BEFORE_MAKE_TIME_HIGH_UVW", "BREAK_BEFORE_MAKE_TIME_LOW_Y2", "BREAK_BEFORE_MAKE_TIME_HIGH_Y2", "USE_ADAPTIVE_DRIVE_TIME_UVW", "USE_ADAPTIVE_DRIVE_TIME_Y2", "DRIVE_TIME_SINK_UVW", "DRIVE_TIME_SOURCE_UVW", "DRIVE_TIME_SINK_Y2", "DRIVE_TIME_SOURCE_Y2", "UVW_SINK_CURRENT", "UVW_SOURCE_CURRENT", "Y2_SINK_CURRENT", "Y2_SOURCE_CURRENT", "BOOTSTRAP_CURRENT_LIMIT", "UNDERVOLTAGE_PROTECTION_SUPPLY_LEVEL", "UNDERVOLTAGE_PROTECTION_VDRV_ENABLE", "UNDERVOLTAGE_PROTECTION_BST_UVW_ENABLE", "UNDERVOLTAGE_PROTECTION_BST_Y2_ENABLE", "OVERCURRENT_PROTECTION_UVW_LOW_SIDE_ENABLE", "OVERCURRENT_PROTECTION_UVW_HIGH_SIDE_ENABLE", "OVERCURRENT_PROTECTION_Y2_LOW_SIDE_ENABLE", "OVERCURRENT_PROTECTION_Y2_HIGH_SIDE_ENABLE", "OVERCURRENT_PROTECTION_UVW_LOW_SIDE_THRESHOLD", "OVERCURRENT_PROTECTION_UVW_HIGH_SIDE_THRESHOLD", "OVERCURRENT_PROTECTION_Y2_LOW_SIDE_THRESHOLD", "OVERCURRENT_PROTECTION_Y2_HIGH_SIDE_THRESHOLD", "OVERCURRENT_PROTECTION_UVW_LOW_SIDE_BLANKING", "OVERCURRENT_PROTECTION_UVW_HIGH_SIDE_BLANKING", "OVERCURRENT_PROTECTION_Y2_LOW_SIDE_BLANKING", "OVERCURRENT_PROTECTION_Y2_HIGH_SIDE_BLANKING", "OVERCURRENT_PROTECTION_UVW_LOW_SIDE_DEGLITCH", "OVERCURRENT_PROTECTION_UVW_HIGH_SIDE_DEGLITCH", "OVERCURRENT_PROTECTION_Y2_LOW_SIDE_DEGLITCH", "OVERCURRENT_PROTECTION_Y2_HIGH_SIDE_DEGLITCH", "OVERCURRENT_PROTECTION_UVW_LOW_SIDE_USE_VDS", "OVERCURRENT_PROTECTION_Y2_LOW_SIDE_USE_VDS", "VGS_SHORT_ON_PROTECTION_UVW_LOW_SIDE_ENABLE", "VGS_SHORT_OFF_PROTECTION_UVW_LOW_SIDE_ENABLE", "VGS_SHORT_ON_PROTECTION_UVW_HIGH_SIDE_ENABLE", "VGS_SHORT_OFF_PROTECTION_UVW_HIGH_SIDE_ENABLE", "VGS_SHORT_ON_PROTECTION_Y2_LOW_SIDE_ENABLE", "VGS_SHORT_OFF_PROTECTION_Y2_LOW_SIDE_ENABLE", "VGS_SHORT_ON_PROTECTION_Y2_HIGH_SIDE_ENABLE", "VGS_SHORT_OFF_PROTECTION_Y2_HIGH_SIDE_ENABLE", "VGS_SHORT_PROTECTION_UVW_BLANKING", "VGS_SHORT_PROTECTION_Y2_BLANKING", "VGS_SHORT_PROTECTION_UVW_DEGLITCH", "VGS_SHORT_PROTECTION_Y2_DEGLITCH", "GDRV_RETRY_BEHAVIOUR", "DRIVE_FAULT_BEHAVIOUR", "FAULT_HANDLER_NUMBER_OF_RETRIES", "SUPPLY_OVERVOLTAGE_WARNING_THRESHOLD", "SUPPLY_UNDERVOLTAGE_WARNING_THRESHOLD", "EXTERNAL_TEMPERATURE_SHUTDOWN_THRESHOLD", "EXTERNAL_TEMPERATURE_WARNING_THRESHOLD", "CHIP_TEMPERATURE_SHUTDOWN_THRESHOLD", "CHIP_TEMPERATURE_WARNING_THRESHOLD", "FIELDWEAKENING_I", "FIELDWEAKENING_VOLTAGE_THRESHOLD", "TARGET_TORQUE_BIQUAD_FILTER_ENABLE", "TARGET_TORQUE_BIQUAD_FILTER_ACOEFF_1", "TARGET_TORQUE_BIQUAD_FILTER_ACOEFF_2", "TARGET_TORQUE_BIQUAD_FILTER_BCOEFF_0", "TARGET_TORQUE_BIQUAD_FILTER_BCOEFF_1", "TARGET_TORQUE_BIQUAD_FILTER_BCOEFF_2", "ACTUAL_VELOCITY_BIQUAD_FILTER_ENABLE", "ACTUAL_VELOCITY_BIQUAD_FILTER_ACOEFF_1", "ACTUAL_VELOCITY_BIQUAD_FILTER_ACOEFF_2", "ACTUAL_VELOCITY_BIQUAD_FILTER_BCOEFF_0", "ACTUAL_VELOCITY_BIQUAD_FILTER_BCOEFF_1", "ACTUAL_VELOCITY_BIQUAD_FILTER_BCOEFF_2" ]

vals = dict()

# Always read params, even if writing afterwards
# This makes sure the params are consistent between the TMC9660 and MCU,
# in case some params have been overwritten directly in the TMC9660, as
# may happen during manual tuning with TMCL-IDE.
for param in rwe_params:
    try:
        vals[param] = node.sdo[param].raw
    except:
        print(f"Could not read {param}")

match args.subcommand:
    case 'read':
        if args.format == 'ini':
            for param, value in vals.items():
                print(f"{param}={value}")
        elif args.format == 'python':
            print(repr(vals))
        elif args.format == 'lely':
            print("  sdo:")
            for param, value in vals.items():
                print("    - { index: " + str(node.object_dictionary[param].index) + ", sub_index: 0, value: " + str(value) + "} # " + param)
    
    case 'write':
        # Read provided ini file
        ini = {}
        for line in open(args.file, 'r'):
            line = line.strip()
            print(line)
            m = re.fullmatch(r'(\w+)\s*=\s*(-?\d+)', line)
            if m and m.groups():
                ini[m.group(1)] = int(m.group(2), 0)

        # Write params
        for param in rwe_params:
            if param in ini:
                print(param, ini[param])
                node.sdo[param].raw = ini[param]
        
        # Persist to flash
        node.store(4)

    case 'reset':
        node.restore(4)

